# 2. 배열의 연산
import numpy as np

# 1) 기본 연산
# 배열의 형태 shape가 같다면 덧셈과 뺄셈, 곱셈과 나눗셈 연산을 할 수 있음.

arr1 = np.array([10, 20, 30, 40])
arr2 = np.array([1, 2, 3, 4])

# 각 배열의 같은 위치의 원소끼리 더함
print(arr1 + arr2)  # [11 22 33 44]

# 두 배열의 차는 같은 위치의 원소끼리 뺌
print(arr1 - arr2)  # [ 9 18 27 36]

# 배열에 상수를 곱하면 각 원소에 상수를 곱함.
print(arr1 * 2)  # [20 40 60 80]

# 배열의 거듭제곱은 배열의 각 원소에 거듭제곱.
print(arr1 ** 2)  # [ 100  400  900 1600]

# 두 배열끼리의 곱셈은 각 원소끼리 곱함.
print(arr1 * arr2)  # [ 10  40  90 160]

# 두 배열의 나눗셈은 각 원소끼리 나눔.
print(arr1 / arr2)  # [10. 10. 10. 10.]

# 배열은 비교 연산도 가능. 원소별로 조건과 일치하는지 검사한 후 일치하면 True를, 그렇지 않으면 False를 반환.
print(arr1 > 20)  # [False False  True  True]

# 2) 통계를 위한 연산
# NumPy에는 배열의 합, 평균, 표준 편차, 분산, 최솟값과 최대값, 누적 합과 누적 곱 등 주로 통계에서 많이 이용하는 메서드가 있음.
# 각각 sum(), mean(), std(0, var(), min(), max(), cumsum(), cumprod()

arr3 = np.arange(5)
print(arr3)  # [0 1 2 3 4]

# 합
print(arr3.sum())  # 10
# 평균
print(arr3.mean())  # 2.0
# 표준 편차
print(arr3.std())  # 1.4142135623730951
# 분산
print(arr3.var())  # 2.0
# 최솟값
print(arr3.min())  # 0
# 최댓값
print(arr3.max())  # 4

arr4 = np.arange(1, 5)
print(arr4)  # [1 2 3 4]
# 누적 합
print(arr4.cumsum())  # [ 1  3  6 10]
# 누적 곱
print(arr4.cumprod())  # [ 1  2  6 24]
print()

# 3. 배열의 인덱싱과 슬라이싱

# 인덱싱 Indexing : 배열의 위치나 조건을 지정해 배열의 원소를 선택.
# 슬라이싱 Slicing : 범위를 지정해 배열의 원소를 선택.

# 1) 배열의 인덱싱.
# 1차원 배열에서 특정 위치의 원소를 선택하려면 원소의 위치를 지정.
# 배열명[위치]
# 배열 원소의 위치는 0부터 시작

a1 = np.array([0, 10, 20, 30, 40, 50])

print(a1[0])
print(a1[4])

# 배열을 변경
a1[5] = 70
print(a1)  # [ 0 10 20 30 40 70]

# 1차원 배열에서 여러 개의 원소를 선택.
# 배열명[위치1, 위치2, ..., 위치n]

print(a1[[1, 3, 4]])  # [10 30 40]

# 2차원 배열에서 특정 위치의 원소를 선택하려면 행과 열의 위치를 지정.
# 배열명[행_위치, 열_위치]

# 10부터 99까지 10씩 증가하는 1차원 배열(개수가 9개)을 생성한 후에 3행 3열의 2차원 배열로 모양을 바꿈
a2 = np.arange(10, 100, 10).reshape(3, 3)
print(a2)
# [[10 20 30]
#  [40 50 60]
#  [70 80 90]]

# 행 위치가 0이고, 열 위치가 2인 원소를 반환
print(a2[0, 2])  # 30

# 2차원 배열의 행과 열의 위치를 지정해서 원소를 선택한 후 값을 변경할 수 있음.
a2[2, 2] = 95
print(a2)
# [[10 20 30]
#  [40 50 60]
#  [70 80 95]]

# 2차원 배열의 여러 원소를 선택하기 위해서 아래와 같이 지정.
# 배열명[[행_위치1, 행_위치2, ..., 행_위치n], [열_위치1, 열_위치2, ..., 열_위치n]]

print(a2[[0,2], [0,1]])  # [10 80]

# 배열에 조건을 지정해 조건을 만족하는 배열은 선택.
# 배열명[조건]
a = np.array([1, 2, 3, 4, 5, 6])
print(a[a > 3])  # [4 5 6]  3보다 큰값만 출력

# 짝수만 선택하는 예.
print(a[(a % 2) == 0])  # [2 4 6]  짝수만 출력

# -인덱스도 사용가능
print(a1[-2])

# 2) 배열의 슬라이싱.
# 1차원 배열의 경우 슬라이싱은 배열의 시작과 끝 위치를 지정.
# 배열[시작_위치:끝_위치]
# 반환되는 원소의 범위는 '시작_위치 ~ 끝_위치 -1'
# 시작위치를 지정하지 않으면 0.
# 끝 위치를 지정하지 않으면 배열이 길이.

b1 = np.array([0, 10, 20, 30, 40, 50])
print(b1[1:4])  # [10 20 30]. 1 ~ 3

# 1차원 배열에서 '시작_위치'와 '끝_위치'를 지정하지 않고 슬라이싱 하는 예.
print(b1[:3])  # [ 0 10 20]

print(b1[2:])  # [20 30 40 50]

print(b1[:])  # [ 0 10 20 30 40 50]

# 슬라이싱을 이용해 원소를 변경할 수 있음.
b1[2:5] = np.array([25, 35, 45])
print(b1)  # [ 0 10 25 35 45 50].  2 ~ 4 변경

# 여러 원소의 값을 같은 값으로 변경하는 예.
b1[3:6] = 60
print(b1)  # [ 0 10 25 60 60 60].  3 ~ 5 변경

